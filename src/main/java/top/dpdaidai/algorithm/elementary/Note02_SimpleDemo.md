
## 理解时间复杂度的例子

#### 一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数 组长度为N，B数组长度为M。 

```

    int[] A = {1,3,5,8,10};
    A.length = N;
    
    int[] B = {7,3,5,2,10,11,1};
    B.length = M;
    
```

#### 算法流程 

1.  对于数组B中的每一个数，都在A中通过遍历的方式找一下； 

    >   双重遍历    
    >   时间复杂度 = O(M*N)  
    ```
        for(int i = 0; i < M; i++ ){
            boolean exist = false;
            for(int j = 0; j < N; j++){
                if (B[i] = A[j]){
                    exist = true;
                    continue;
                }
            }    
            if ( !exist ){
                System.out.println(B[i]);
            }
        }
    
    ```

2.  对于数组B中的每一个数，都在A中通过二分的方式找一下； 
    >   由于A是有序数组, 遍历查找的时候A数组可以通过二分法减少遍历次数 .     
    >   时间复杂度 = O(M * logN)
    ```
        for(int i = 0; i < M; i++ ){
            boolean exist = false;
            // 后面再补二分查找的代码吧 ..
        
        }
        
    ```

3.  先把数组B排序，然后用类似外排的方式打印所有在A中出现 的数； 
    >   先将B数组排序 , 排序的时间复杂度是  O(M * logM)        
    >   再用类似外排的方式打印 , 时间复杂度是 O(M + N)       
    >   总的时间复杂度 = O(M * logM) + O(M + N) 
    ```
    
    ```


#### 如何分析好坏？
+   算法一效率最低
+   算法二和算法三 , 需要根据 M 和 N 的数据量大小进行分析
