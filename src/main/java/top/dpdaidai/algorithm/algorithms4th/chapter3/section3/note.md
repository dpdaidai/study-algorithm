## 3.3 平衡查找树
二叉查找树在随机情况下已经很好 , 但是它在最坏的输入情况下(键有序插入) , 性能还是很差    
平衡查找树 : 
1.  二叉查找树
2.  无论如何构造, 插入和查找都是对数级别
3.  保持二分查找树的平衡性 , 但不是完美平衡(代价过高)

#### 3.3.1 2-3 查找树
一颗2-3查找树或为一颗空树, 或由以下节点组成 : 
1.  2- 节点 : 含有一个键和两条链接, 左链接指向2-3树中的键都小于该节点 , 右链接指向树中的键都大于该节点
2.  3- 节点 : 含有两个键和三条链接 , 左链接指向2-3树中的键都小于该节点 , 
中链接指向2-3树中的键都位于该节点两个键之间 , 右链接指向树中的键都大于该节点

一颗 ***完美平衡*** 的2-3查找树中的所有空链接到根节点的距离都应该是相同的 . 

###### 1) 查找
同二叉查找树 , 根据键和节点的比较, 来选择下一个链接 , 递归进行

###### 2) 向2-节点中插入新键
如果插入一个节点位于一个 2- 节点 : 
1.  如果将插入的节点保存在 2- 节点的底部 , 则树高度增加 , 无法保持树的平衡性
2.  我们需要把这个 2- 节点替换为 3- 节点即可 

###### 3) 向一颗只有一个3-节点的树中插入新建
1.  为了将新键插入, 我们先临时将新建存入父节点, 使它成为一个4-节点
2.  将4-节点装换为3个2-节点 , 树的高度增加1 

这样做所有的空链接到根节点的距离都相等 , 它任然是一颗完美平衡的 2-3 树

###### 4) 向一个父节点为2-节点的 3- 节点插入新键
假设 未命中的查找结束于 3- 节点 , 它父节点为2-节点 , 这时为了维持树的完美平衡的前提为新建腾出空间
1.  构造一个临时 4- 节点 , 将新键插入
2.  将4- 节点分解 
3.  将分解后的中键移动到父节点 , 使父节点成为一个 3- 节点

###### 5) 向一个父节点为 3- 节点的 3- 节点中插入新键
1.  构造临时4-节点 , 将新建插入
2.  分解4- 节点 
3.  将分解后的中键移动到父节点 , 使父节点成为一个 4- 节点
4.  我们需要一直不断向上分解 , 直到父节点为 2- 节点 , 或者到达节点根部

###### 6) 分解根节点 
如果插入节点到根节点全部是 3- 节点, 我们的根节点最终变成一个临时的 4- 节点 , 
此时将根节点分解 , 树高加1 , 树平衡性不变

###### 7) 局部变换
将 4- 节点分解有6种情况 , 但是根本在于这些变换都是局部的 : 
1.  除了相关节点 , 不必修改和检查树的其它部分
2.  变更的链接数量不会超过一个很小的常数
3.  树中的任何地方 , 只要符合相应的模式 , 变换都可以进行 

###### 8) 全局性质
局部变换不会影响树的全局有序性和平衡性 : 
1.  任意空链接到根节点的路径长度都是相等的.
2.  只有当根节点被分解时 , 树的高度才会加1 . 
3.  局部变换不会影响树的有序性和平衡性
4.  标准二叉树由上向下生长 , 2-3 树由下向上生长  

###### 9) 性能
1.  在一颗大小为N的 2-3 树中, 插入和查找操作访问的节点必然不会超过lgN个
2.  即使在最坏情况下 , 2-3 树任然有较好性能
3.  每个操作中处理节点的时间都不会超过一个很小的常数
4.  操作只会访问一条路径行的节点
5.  所以操作的成本不会超过对数级别

###### 10) 缺点
1.  2-3 树表示的情况太多 , 需要处理的代码也更多
2.  需要维护两种类型的节点 , 甚至三种 , 将被查找的键和节点的键比较, 将链接复制到其它节点 , 转换节点数据类型需要大量代码
3.  复杂代码的额外开销可能导致比标准二叉树更慢
4.  平衡二叉树的目的是消除最差情况 , 希望能够在较小代价下达到目的

#### 3.3.2 红黑二叉查找树
红黑二叉树的基本思想 :  
1.  用标准二叉树和一些额外信息来表示 2-3树 
2.  红链接 : 将两个2-节点连接起来构成一个 3- 节点
3.  黑链接 : 2-3 树中的普通链接
###### 1) 替换 3- 节点
确切的说我们将 3- 节点表示为 : 由一条左斜的红色链接连接的两个 2- 节点 

优点 : 
1.  我们无需修改就可以直接适用标准二叉树的 get() 方法
2.  对于任意2-3树, 只要对节点进行转换 , 我们都可以立刻派生出一颗对应的二叉查找树

###### 2) 等价的定义
红黑树 : 
1.  红链接都为左链接
2.  没有任何一个节点同时和两个红链接相连
3.  树是 ***完美黑色平衡*** , 即空链接到根节点的路径上的黑链接数量相同

###### 3) 与2-3树一一对应
1.  将红链接画平, 那么空链接到根节点的距离相同
2.  将红链接合并 , 称为一颗 2-3 树
3.  黑链接为普通链接 , 树是黑色平衡
4.  保持一一对应关系 , 在二叉树的基础上实现 2-3 树, 那么就可以保持二叉查找树的简洁高效的查找方法
和 2-3 树的平衡插入算法

###### 4) 颜色表示
因为每个节点都只会有一条指向自己的链接 , 我们将链接的颜色保存在表示节点的Node数据类型的布尔变量color中,
约定默认变量为false , true表示红色 . 我们提到一个节点的颜色时 , 指的是指向该节点的链接颜色.

###### 5) 场景预测
我们每次新增节点时 :  
1.  在 2- 节点中插入 变为 3- 节点
2.  在 3- 节点中插入 变为 4- 节点

在某些操作中可能出现红色右链接或者两条连续的红链接, 但在操作完成前, 这些情况都会被小心的修复   
所有新建节点都会设置为红色 . 于是就会出现以下情况 : 
1.  在 2- 节点 E 中插入节点 D , 那么 D 在 E 左边 , 形成一个 标准 3- 节点 , 无需变换
2.  在 2- 节点 E 中插入节点 F , 那么 F 在 E 右边 , 父链接指向E , 需要将 E 左旋使它称为一个标准 3- 节点
3.  在 3- 节点 D-E 中插入节点 F , 那么形成一个父链接指向 E , 而 E 节点的左右都是红色链接 的 D-E-F  4- 节点 
    1.  进行颜色变换 , 将 DEF 4- 节点 的 E 上升到父节点 , D 和 F 形成两个 2- 节点
4.  在 3- 节点 E-F 中插入 节点 D , 那么形成一个父链接指向 F, 而 F 节点的左链接和 E 的左链接都是红色的 4- 节点  
    1.  将 F 右旋 , 形成一个父链接指向E的 D-E-F 4- 节点 , 后续同3 
5.  在 3- 节点 D-F 中插入节点 E , 那么 D 的父链接和右子链接都是红色
    1.  将 D 左旋 , 得到 4 中的情况 , 后续同 4 

###### 6) 旋转

左旋转 : 它对应的方法接收一条指向某个节点的链接作为参数 , 假设节点的右链接是红色的 , 这个方法
会对树进行必要的调整 , 并返回一个指向包含同一组键的子树, 且其左链接为红色的根节点的链接 
1.  将较小者的节点颜色和较大者的节点颜色交换
2.  修改将两个节点中的中间子节点的的父节点
3.  更新两个键的 N
4.  将用两个键中的较小者作为根节点变为将较大者作为根节点 , 函数返回右侧较大的节点作为根节点

右旋转 : 代码和左旋转基本相同 , 只需要将left和right互换即可

在新插入键时 , 我们使用旋转操作帮助我们保证 2-3 树和红黑树之间的一一对应关系 , 因为旋转
可以保持红黑树的两个重要性质 : ***有序性和完美平衡性***

###### 7) 向单个2-节点中插入新键
1.  新键小于老键 : 增加一个红色节点 , 与 2-3 树的 3- 节点等价
2.  新键大于老键 : 增加一个红色节点 , 对老键进行以此左旋即可

###### 8) 向一颗双键树(3-节点)插入新键
会产生一个同时连接到两个红色链接的节点 , 我们会通过旋转修正它
1.  新键大于原树的两个键 : 根节点为中间键 , 它左右都为红色链接 
    +   将两个链接由红变黑, 那么就得到一个三个节点组成, 高度为2的平衡树 
2.  新键小于原树的两个键 : 根节点为最大键 , 根节点左边有两条连续的红色链接
    +   将根节点右旋 , 得到情况1
3.  新键介于两个键之间 : 又回产生两个连续的红链接 , 一条红色左链接接一条红色右链接 
    +   只需要将下层的红链接左旋即可得到情况2
    
###### 9) 颜色变换
上述8中的第一种情况下 , 分解 4- 节点 : 
1.  将4-节点内左右两个节点的颜色由红变黑 (将4- 节点分解为3个2- 节点)
2.  将中间节点的颜色由黑变红 (将中间节点上升送入父节点 , 与父节点合并为 3- 或者 4- 节点)
3.  如果父节点变为了 4- 节点 , 那么还需要继续向上分解 , 直到根节点

这个操作最重要的性质在于它和旋转操作一样是局部变换 , 不会影响树的黑色平衡

###### 10) 根节点保持黑色 
在由下向上分解过程中 , 如果根节点也经历了以此颜色变换 , 那么根节点就会变为红色 , 所以最后需要将
根节点手动修改为黑色

###### 11) 将红链接在树中向上传递
只要适用左旋, 右旋和颜色变换三种简单操作, 就能保证插入操作后红黑树和和2-3树的一一对应关系 . 
在沿着插入点到根节点的路径向上移动时 , 在所经过的每个节点中顺序完成以下操作,  我们就可以完成插入操作 : 
1.  如果右子节点是红色, 而左子节点是黑色, 进行左旋转
    + 在一个 2- 节点的右侧插入新键后 , 左旋形成一个 3- 节点
    + 插入的新节点和树底部的3-节点的左节点的右子节点相连 , 将左子节点左旋形成一个 4- 节点 
2.  如果左子节点是红色, 且左子节点的左子节点还是红色 , 那么进行右旋转
    + 4- 节点的根节点为最右侧的节点 , 将最右侧节点右旋 , 形成一个标准 4- 节点
3.  如果左右子节点均为红色 , 进行颜色变换
    + 将标准 4- 节点分解

#### 3.3.3 实现红黑树
保持树的平衡性所需的操作由下向上 , 在每个所经过的节点中进行 , 只需要在递归调用后完成这些操作即可 .  

put()插入完成后 , 检测所有经过的节点 : 
1.  检测当前节点右侧是否是红色节点 而 左侧不是红色节点 
    +   左旋 , 得到标准 3- 节点, 或者得到下 2 
2.  检测当前节点的左子节点和左子节点的左子节点是否都为红色
    +   右旋 , 得到标准的 4- 节点
3.  检测当前节点的左右子节点是否都为红色节点
    +   颜色变换 , 将中间节点送入父节点
4.  向下向上以此操作 , 直到根节点

#### 3.3.4 删除操作
红黑树的delete操作比put()更加麻烦 , 因为单纯的删除节点会导致树不在黑色平衡 .
1.  不仅要在构造临时4-节点时 , 沿着查找路径向下进行变换
2.  还要在分解遗留的4-节点时 , 沿着查找路径向上进行变换

###### 1) 自顶向下的 2-3-4 树
我们先学习一个沿查找路径即能向上又能向下进行变换的算法 : 2-3-4树的插入算法 . 
2-3-4树 允许树中存在4-节点 . 
插入算法 :
1.  在向下查找的过程中  
    1.  如果如果遇到一个父节点为2-节点的4-节点 , 将4-节点分解为两个2-节点 ,
    并将中间键传递给它的父节点 , 使父节点变为3-节点
    2.  如果父节点为 3- 节点 的 4- 节点 , 将 4- 节点分解 , 将父节点变为 4- 节点 
2.  到底树的底部后 , 我们只会遇到2-节点或者3-节点 , 所以可以插入新键
3.  在向上过程中 , 用旋转将 4- 节点配平

###### 2) 删除最小键
从树底部的3-节点中删除键是很简单的 , 但是 2- 节点却不同 , 从2-节点删除会留下一个空链接 , 
这样会破坏树的完美平衡性
为了保证不会删除一个 2- 节点 , 我们沿着左链接向下进行变换 , 确保当前节点不是 2- 节点 
(可以是3- 或者 4- 节点) .   

沿着左链接向下检索的过程中 :  
1.  如果当前节点的左子节点不是 2- 节点 , 完成
2.  如果当前节点的左子节点是 2- 节点 , 而它的亲兄弟节点不是 2- 节点 , 将左子节点的兄弟节点
中的一个键移动到当前节点 , 再将当前节点的一个键移动到左子节点
3.  如果当前节点的左子节点和它的亲兄弟节点都是 2- 节点 , 将 左子节点 , 父节点中的一个键 , 
还有左子节点最近的兄弟节点合并为一个 4- 节点 , 使父节点由 3- 变为 2- 节点 或者由 4- 节点变为 3- 节点

最后能够得到一个含有最小键的 3- 节点或者 4- 节点 , 然后我们就可以将最小键从节点中删除 , 
然后我们再回头向上分解所有临时的 4- 节点

###### 3) 删除操作
1.  在查找路上进行和删除操作相同的变换 , 同样可以保证在查找过程中任意当前节点君不是 2- 节点
2.  如果被查找的键在树的底部, 我们可以直接删除它
3.  如果不是树的底部节点中的键
    1.  设被删除的键为 t 
    2.  寻找 t 的后继键 , 保存为 x 
    3.  删除 t 的右子树中的最小键 (操作如上述 "删除最小键" ) , 即删除右子树中的 x 键 
    4.  将 t 和 x 交换 , 就和二叉查找树一样
4.  删除之后 , 需要向上回溯并分解余下的 4- 节点 

#### 3.3.5 红黑树的性质
我们最终结论是所有基于红黑树的符号表实现都能保证操作的运行时间是对数级别 (范围查找除外) 
###### 1) 性能分析
1.  无论键的插入顺序如何, 红黑树都几乎是完美平衡的
2.  一颗大小为N的红黑树的高度不会超过2lgN
    + 最坏情况是它所对应的2-3 树中最左边的路径节点去啊怒视 3- 节点 , 此时最左边的路径长度是
    只包含2- 节点的路径长度 (~lgN) 的两倍
3.  一颗大小为N的红黑树中, 根节点到任意节点的平均路径长度为 ~1.001lgN
4.  红黑树的get()方法不会检查节点颜色 , 因此平衡性操作不会对get()产生负担
5.  因为树是平衡的 , 所以查找比二叉树更快
6.  查找的内循环只会进行以此比较, 并更新一条链接 , 非常简短

这是我们见到的第一个能保证对数级别的查找和插入操作的实现, 它的内循环更加紧凑

###### 2) 有序的符号表API
1.  红黑树最复杂的代码仅限于 put() 和 删除相关操作 . 
2.  它其余操作都可以继续使用二叉查找树的代码 
3.  它其余操作都可以从平衡性中收益, 因为它们最多所需的时间都和树高成正比


