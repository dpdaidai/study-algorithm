## 3.1 符号表
符号表的目的就是将一个键和值联系起来 . 用例能够将一个键值对插入符号表并希望在之后能够从符号
表的所有键值对种按照键直接找到相应的值 . 

目标 : 
1.  高效的插入键值对 (put)
2.  根据键快速查找对应的值 (get)

实现 : 
1.  定义数据结构
2.  实现插入, 查找等操作所需的算法

#### 3.1.1 API
和以前一样 , 我们要应用程序编程接口(API)来精确定义这些操作, 为数据类型的实现和用例提供一份"契约"

1.  ST()构造方法
1.  put(Key key, Value val) 存入
2.  get(Key key) 获取key对应的值
3.  delete(Key key) 从表中删除键Key
4.  contains(Key key) 键key是否在表中有对应的值
5.  isEmpty() 表是否为空
6.  size() 返回表中键值对数量
7.  Iterable<Key> keys() 表中所有键的集合

###### 具体实现种的几个设计决策
###### 1) 泛型
对于符号表, 我们通过明确的指定查找时键和值的类型来区分它们的不同角色.   
我们还会使用Comparable的对象来扩展典型的用例, 这也会为数据类型带来许多新的方法.
###### 2) 重复的键
1.  每个键对应着一个值, 表中不允许重复的键
2.  存入的键已经存在时, 新的值会替代旧的值
###### 3) 空键
键不能为空
###### 4) 空值
不允许有空值, 当键不存在时, get()方法会返回空, 意味着任何不在表种的键关联的值都为空.
1.  我们会使用返回的值是否为空来测定给定的键是否存在于符号表
2.  我们可以键空值存入表中来实现删除 -- put(key, null)
###### 5) 删除操作
删除有延时删除和即时删除
1.  延时删除 : 将键对应的值设置为null,然后在某个时候删去所有值为空的键
2.  即时删除 : 立刻从表中删除指定的键
###### 6) 便捷方法
###### 7) 迭代
为了方便用例处理表中所有的键值
1.  我们定义了keys()方法来返回一个Iterable<Key>对象以方便用例遍历所有的键.
2.  在Key有序时, 还可以keys(Key lo, Key hi)来返回[lo,hi]之间所有的键

###### 8) 键的等价性
按照约定所有的对象都继承equals()方法, 以此判断键是否相等.
最好使用不可变的数据类型做为键, 否则表的一致性是无法保证的

#### 3.1.2 有序符号表
1.  典型的应用程序中, 键都是Comparable的对象, 因此可以用a.compareTo(b)来比较a和b两个键.
2.  许多符号表的实现都利用了Comparable接口带来的键的有序性来更好的实现put()和get()方法
3.  在这些实现中, 可以认为符号表都会保持键的有序并大大扩展它的API, 根据键的相对位置定义更多使用的操作

###### 1) API
以下操作定义了一个有序符号表
1.  ST() 构造方法
2.  put(Key key, Value val) 存入
3.  get(Key key) 获取key对应的值
4.  delete(Key key) 从表中删除键Key
5.  contains(Key key) 键key是否在表中有对应的值
6.  isEmpty() 表是否为空
7.  size() 返回表中键值对数量
8.  Key min() 最小的键
9.  Key max() 最大的键
10. Key floor(Key key) 小于等于Key的最大键
11. Key ceiling(Key key) 大于等于Key的最小键
12. int rank(Key key) 小于key的键的数量
13. Key select(int k) 排名为k的键
14. void deleteMin() 删除最小的键
15. void deleteMax() 删除最大的键
16. int size(Key lo, Key hi) [lo,hi]之间所有的键的数量
17. Iterable<Key> keys(Key lo, Key hi) [lo,hi]之间所有的键, 已排序
8.  Iterable<Key> keys() 表中所有键的集合 , 已排序

只要看到类的声明中包含 <Key extends Comparable> 就说明程序是在实现这份API

###### 2) 最大键和最小键
可快速查询和删除最大键和最小键

###### 3) 向下取整和向上取整
1.  floor : 找出小于等于该键的最大键
2.  ceiling : 找出大于等于该键的最小键

###### 4) 排名rank和选择select
检验一个新的键是否插入合适位置的基本操作是排名rank和选择select.
1.  i == rank(select(i))
2.  key == select(rank(key))

对于符号表, 我们的 ***挑战*** 是在实现插入, 删除 , 查找的同时, 快速实现这两种操作

###### 5) 范围查找
1. int size(Key lo, Key hi) [lo,hi]之间所有的键的数量
2. Iterable<Key> keys(Key lo, Key hi) [lo,hi]之间所有的键, 已排序

这两个方法能够实现范围查询 , 这是有序符号表在实践中广泛应用的重要原因

###### 6) 例外情况
当一个方法需要返回一个键, 但表中没有合适的键可以返回时, 约定抛出一个异常 
1.  符号表为空时 : min(), max() , deleteMin(), deleteMax(), floor(), ceiling()
2.  当k<0 或 k>=size()时, select(k)也会抛出异常 

###### 7) 部分API的通用实现
###### 8) 键的等价性
任何一种Comparable类型的两个值需要保证 a.compareTo(b)==0 和 a.equals(b) 的返回值相同

###### 9) 成本模型
查找的成本模型 : 我们会统计比较的次数, 在内循环不进行比较时, 我们会统计数组的访问次数
