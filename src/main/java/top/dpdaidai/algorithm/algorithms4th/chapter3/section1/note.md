## 3.1 符号表
符号表的目的就是将一个键和值联系起来 . 用例能够将一个键值对插入符号表并希望在之后能够从符号
表的所有键值对种按照键直接找到相应的值 . 

目标 : 
1.  高效的插入键值对 (put)
2.  根据键快速查找对应的值 (get)

实现 : 
1.  定义数据结构
2.  实现插入, 查找等操作所需的算法

#### 3.1.1 API
和以前一样 , 我们要应用程序编程接口(API)来精确定义这些操作, 为数据类型的实现和用例提供一份"契约"

1.  ST()构造方法
1.  put(Key key, Value val) 存入
2.  get(Key key) 获取key对应的值
3.  delete(Key key) 从表中删除键Key
4.  contains(Key key) 键key是否在表中有对应的值
5.  isEmpty() 表是否为空
6.  size() 返回表中键值对数量
7.  Iterable<Key> keys() 表中所有键的集合

###### 具体实现种的几个设计决策
###### 1) 泛型
对于符号表, 我们通过明确的指定查找时键和值的类型来区分它们的不同角色.   
我们还会使用Comparable的对象来扩展典型的用例, 这也会为数据类型带来许多新的方法.
###### 2) 重复的键
1.  每个键对应着一个值, 表中不允许重复的键
2.  存入的键已经存在时, 新的值会替代旧的值
###### 3) 空键
键不能为空
###### 4) 空值
不允许有空值, 当键不存在时, get()方法会返回空, 意味着任何不在表种的键关联的值都为空.
1.  我们会使用返回的值是否为空来测定给定的键是否存在于符号表
2.  我们可以键空值存入表中来实现删除 -- put(key, null)
###### 5) 删除操作
删除有延时删除和即时删除
1.  延时删除 : 将键对应的值设置为null,然后在某个时候删去所有值为空的键
2.  即时删除 : 立刻从表中删除指定的键
###### 6) 便捷方法
###### 7) 迭代
为了方便用例处理表中所有的键值
1.  我们定义了keys()方法来返回一个Iterable<Key>对象以方便用例遍历所有的键.
2.  在Key有序时, 还可以keys(Key lo, Key hi)来返回[lo,hi]之间所有的键

###### 8) 键的等价性
按照约定所有的对象都继承equals()方法, 以此判断键是否相等.
最好使用不可变的数据类型做为键, 否则表的一致性是无法保证的

#### 3.1.2 有序符号表
1.  典型的应用程序中, 键都是Comparable的对象, 因此可以用a.compareTo(b)来比较a和b两个键.
2.  许多符号表的实现都利用了Comparable接口带来的键的有序性来更好的实现put()和get()方法
3.  在这些实现中, 可以认为符号表都会保持键的有序并大大扩展它的API, 根据键的相对位置定义更多使用的操作

###### 1) API
以下操作定义了一个有序符号表
1.  ST() 构造方法
2.  put(Key key, Value val) 存入
3.  get(Key key) 获取key对应的值
4.  delete(Key key) 从表中删除键Key
5.  contains(Key key) 键key是否在表中有对应的值
6.  isEmpty() 表是否为空
7.  size() 返回表中键值对数量
8.  Key min() 最小的键
9.  Key max() 最大的键
10. Key floor(Key key) 小于等于Key的最大键
11. Key ceiling(Key key) 大于等于Key的最小键
12. int rank(Key key) 小于key的键的数量
13. Key select(int k) 排名为k的键
14. void deleteMin() 删除最小的键
15. void deleteMax() 删除最大的键
16. int size(Key lo, Key hi) [lo,hi]之间所有的键的数量
17. Iterable<Key> keys(Key lo, Key hi) [lo,hi]之间所有的键, 已排序
18.  Iterable<Key> keys() 表中所有键的集合 , 已排序

只要看到类的声明中包含 <Key extends Comparable> 就说明程序是在实现这份API

###### 2) 最大键和最小键
可快速查询和删除最大键和最小键

###### 3) 向下取整和向上取整
1.  floor : 找出小于等于该键的最大键
2.  ceiling : 找出大于等于该键的最小键

###### 4) 排名rank和选择select
检验一个新的键是否插入合适位置的基本操作是排名rank和选择select.
1.  i == rank(select(i))
2.  key == select(rank(key))

对于符号表, 我们的 ***挑战*** 是在实现插入, 删除 , 查找的同时, 快速实现这两种操作

###### 5) 范围查找
1. int size(Key lo, Key hi) [lo,hi]之间所有的键的数量
2. Iterable<Key> keys(Key lo, Key hi) [lo,hi]之间所有的键, 已排序

这两个方法能够实现范围查询 , 这是有序符号表在实践中广泛应用的重要原因

###### 6) 例外情况
当一个方法需要返回一个键, 但表中没有合适的键可以返回时, 约定抛出一个异常 
1.  符号表为空时 : min(), max() , deleteMin(), deleteMax(), floor(), ceiling()
2.  当k<0 或 k>=size()时, select(k)也会抛出异常 

###### 7) 部分API的通用实现
###### 8) 键的等价性
任何一种Comparable类型的两个值需要保证 a.compareTo(b)==0 和 a.equals(b) 的返回值相同

###### 9) 成本模型
查找的成本模型 : 我们会统计比较的次数, 在内循环不进行比较时, 我们会统计数组的访问次数

#### 3.1.3 用例举例
###### 1) 行为测试用例
用于跟踪算法的行为 , 测试符号表在put行为下内部的实现
1.  对于符号表的简单实现(无序) , 用例的输出中键的顺序是不确定的
2.  对于有序符号表, 用例应该将键按顺序打印出来 

###### 2) 性能测试用例
从标准输入种得到一列字符串, 并记录每个字符串出现的次数, 然后遍历所有键并找出出现频率最高的键.

###### 3) 共性 
研究符号表处理大型文本性能要考虑两个因素 : 
1.  首先每个单词都会被作为键进行搜索, 因此处理性能和输入文本的单词总量必然有关
2.  其次输入的每次单词都会被存入符号表, 因此输入流种不同的单词的总数也是相关的

符号表应用的共性 : 
1.  混合使用查找和插入操作
2.  大量不同的键
3.  查找比插入快的多

#### 3.1.4 无序链表的顺序查找
使用链表完成符号表 , 顺序查找
1.  每个节点存储一个键值对
2.  get() 实现为遍历链表, 用equals()方法比较每个节点的键
    1.  匹配成功返回相印的值
    2.  失败返回null
3.  put() 实现也是遍历链表, 用equals()方法比较每个节点的键
    1.  匹配成功, 就替换值
    2.  匹配失败用给定的键值对创建一个新的节点, 并插入链表的开头
4.  使用了一个私有内部Node类来在链表中保存键和值 , get和put都会顺序遍历链表进行搜索

基于链表的顺序查找运行时间 : 
1.  在含有N对键值对的无需符号表中 , 未命中的查找和插入操作都需要N次比较 . 
2.  向一个空表种插入N个不同的键需要 ~N²/2次比较
3.  命中的查找在最坏的情况下需要N次比较
4.  查找N个键的总时间 / N 就是单个键的平均查找时间 , 称为随机命中 . 平均比较次数 = ~N/2
5.  比较总次数 = 查找次数 * 插入次数 --> 对于N个键 , 查找M次 , 比较次数 = M * N/2  
6.  
