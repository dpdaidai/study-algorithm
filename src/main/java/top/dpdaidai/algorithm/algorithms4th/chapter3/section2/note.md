## 二叉查找树
它是能够将链表插入的灵活性和有序数组查找的高效性结合起来符号表
1.  它是一颗二叉树
2.  每个节点都含有一个Comparable的键, 已经它关联的值
3.  每个节点的键都大于其左子树中 ***任意节点*** 的值
4.  每个节点的键都小于其右子树中 ***任意节点*** 的值

#### 3.2.1 基本实现
###### 1) 数据表示
1.  我们嵌套定义了一个私有类来表示二叉查找树上的一个节点
2.  节点数据
    + 键
    + 值
    + 左链接
    + 右链接
    + 本节点的树大小 N
3.  左链接指向一颗由小于该节点的所有键组成的二叉查找树
4.  右链接指向一颗由大于该节点的所有键组成的二叉查找树
5.  变量 N 给出了以该节点为根的子树的节点总数 , N = size(left) + size(right) + 1

###### 2) 查找
1.  树为空 , 查找未命中
2.  被查找的键和根节点的键相等 , 查找命中
3.  否则递归的在适当的子树中继续查找
4.  和二分查找中每次迭代之后查找的区间就会减半一样, 每次向下查找子树也会变小
5.  对于未命中的查找 , 路径的终点是个空链接

###### 3) 插入
1.  如果查找的键小于根节点的键, 则在左子树中插入该键
2.  如果查找的键大于根节点的键, 则在右子树中插入该键
3.  查找一个不存在于树中的节点, 并结束于一条空链接时 , 将链接指向新节点

#### 3.2.2 分析
使用二叉树的算法的运行时间取决于树的形状, 树的形状取决于键插入顺序 : 
1.  最好情况 : 树为完全平衡的 , 每条空链接和根节点的距离都为 ~lgN
2.  最坏情况 : 搜索路径上可能有N个节点 , 完全不平衡
3.  一般情况 : 在大量键的情况下 , 树的形状和最好情况接近

简单模型 : 
1.  键的分布均匀 , 或者插入随机
2.  二叉查找树和快速排序很像
3.  树的根节点就是快速排序的第一个切分元素
4.  子树的递归和快速排序对子数组的递归排序完全对应

在N个随机键构成的二叉查找树中运行时间 : 
1.  查找命中 : 平均比较次数 ~2lnN = ~1.39lgN
2.  查找未命中和插入操作 : 平均所需比较次数 ~2lnN

在上述运行时间的预测 , 有可能受到干扰 : 
1.  符号表较小
2.  键不随机
