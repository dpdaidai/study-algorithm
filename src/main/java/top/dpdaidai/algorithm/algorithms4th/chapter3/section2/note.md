## 二叉查找树
它是能够将链表插入的灵活性和有序数组查找的高效性结合起来符号表
1.  它是一颗二叉树
2.  每个节点都含有一个Comparable的键, 已经它关联的值
3.  每个节点的键都大于其左子树中 ***任意节点*** 的值
4.  每个节点的键都小于其右子树中 ***任意节点*** 的值

#### 3.2.1 基本实现
###### 1) 数据表示
1.  我们嵌套定义了一个私有类来表示二叉查找树上的一个节点
2.  节点数据
    + 键
    + 值
    + 左链接
    + 右链接
    + 本节点的树大小 N
3.  左链接指向一颗由小于该节点的所有键组成的二叉查找树
4.  右链接指向一颗由大于该节点的所有键组成的二叉查找树
5.  变量 N 给出了以该节点为根的子树的节点总数 , N = size(left) + size(right) + 1

###### 2) 查找
1.  树为空 , 查找未命中
2.  被查找的键和根节点的键相等 , 查找命中
3.  否则递归的在适当的子树中继续查找
4.  和二分查找中每次迭代之后查找的区间就会减半一样, 每次向下查找子树也会变小
5.  对于未命中的查找 , 路径的终点是个空链接

###### 3) 插入
1.  如果查找的键小于根节点的键, 则在左子树中插入该键
2.  如果查找的键大于根节点的键, 则在右子树中插入该键
3.  查找一个不存在于树中的节点, 并结束于一条空链接时 , 将链接指向新节点

#### 3.2.2 分析
使用二叉树的算法的运行时间取决于树的形状, 树的形状取决于键插入顺序 : 
1.  最好情况 : 树为完全平衡的 , 每条空链接和根节点的距离都为 ~lgN
2.  最坏情况 : 搜索路径上可能有N个节点 , 完全不平衡
3.  一般情况 : 在大量键的情况下 , 树的形状和最好情况接近

简单模型 : 
1.  键的分布均匀 , 或者插入随机
2.  二叉查找树和快速排序很像
3.  树的根节点就是快速排序的第一个切分元素
4.  子树的递归和快速排序对子数组的递归排序完全对应

在N个随机键构成的二叉查找树中运行时间 : 
1.  查找命中 : 平均比较次数 ~2lnN = ~1.39lgN
2.  查找未命中和插入操作 : 平均所需比较次数 ~2lnN

在上述运行时间的预测 , 有可能受到干扰 : 
1.  符号表较小
2.  键不随机

#### 3.2.3 有序性相关的方法和删除
二叉查找树能得以广泛应用得一个重要原因就是它能保持键得有序性 . 
可通过键得顺序访问键值对
###### 1) 最大键和最小键
最小键 : 
1.  根节点得左链接为空, 那么根节点就是最小得键
2.  左链接非空 , 那么树的最小键就是左子树中的最小键 

###### 2) 向上取整和向下取整
想下取整 : 
1.  key 等于根节点 , 根就是小于等于key的最大键
2.  key 小于根节点 , 那么floor(key)一定在根节点得左子树中
3.  key 大于根节点 
    + 右子树存在小于等于 key 的节点 , 那么floor(key)在右子树
    + 否则 根节点就是 小于key的最大键

###### 3) 选择操作
我们在二叉树的每个节点维护的子树节点计数变量N .  
假设我们想找到排名为k的键 (从0开始) . 
1.  左子树中的节点数 t > k , 那么递归的在左子树中查找排名为k的键
2.  t = k , 那么根节点就是排名为k的键
3.  t < k , 那么递归的在右子树中查找排名为 k-t-1 的键

###### 4) 排名
rank() 是select() 的逆方法 , 它会返回给定键的排名 
1.  给定键 = 根节点的键 , 返回左子树中的节点总数 t
2.  给定键 < 根节点的键 , 返回该键在左子树的排名
3.  给定键 > 根节点的键 , 返回该键在右子树的排名 + t + 1

###### 5) 删除最大键和删除最小键
二叉查找树最难实现的就是delete()方法 . 
删除最小键 : 
1.  查找树中最右端的键 , 它是没有左节点的键
2.  该键没有右节点 , 那么将父节点的left设置为null
3.  该键有右节点 , 那么将父节点的left指向它的右节点

###### 6) 删除操作
如果删除有两个子树的节点呢 , 因为两个子节点并不是两个子树中的极大或者极小键
删除一个节点后 , 用它的后继节点替补它的位置 , 
那么需要查找右子树的最小键或者左子树的最大键 , 用它们来替换被删除的节点
1.  将指向被删除节点的引用保存为 t
2.  将右子树最小键的引用保存为 x
3.  删除右子树的最小节点,  然后返回右子树的根节点
4.  设置替换节点x的左右节点
5.  返回替换节点x的引用
6.  更新沿路所有受影响节点的 N
这个方法有可能会有问题 : 一致选用右子树中的节点来替换 , 当一个符号表进行了大量的
删除和插入操作后 , 平衡性就被严重破坏了 , 实际上应该随机选择 左子树或者右子树中
的节点来替换

###### 7) 范围查找
要实现能够返回给定范围内的keys()方法, 首先需要一个遍历二叉树的方法 , 叫做 ***中序遍历***   
首先看如果按顺序打印一个树中的所有键
1.  首先打印根节点的左子树中所有的键
2.  打印根节点的键
3.  打印右子树中所有的键
将上述打印出来的键依次放入一个可迭代的队列即可实现    

按顺序返回[lo , hi]所有的键 :
1.  lo < 根节点 , 递归的将左子树中所有 大于 lo 的键放入队列
2.  lo <= 根节点 <= hi , 将根的键放入队列
3.  根节点 < hi , 递归的将右子树所有小于等于 hi 的键放入队列
 
###### 8) 性能分析
1.  二叉查找树中, 所有操作在最坏情况下所需的时间都和树的高度成正比 , 我们可以认为
随机构造的树中所有路径长度都小于 3lgN     
2.  但是在最坏的情况下的恶劣性能任然是不可接收的 , 例如 : 用例将所有键按照顺序或者
逆序插入符号表 , 那么构造的树就是一条长度为N的链表 , 查找和插入增长数量级都是N   
3.  二叉查找树的良好性能依赖于其中的键的分布足够随机以消除长路径
