## 2.3 快速排序

#### 2.3.1 算法流程
快速排序是一种分治的排序算法 , 它将数组分成两个子数组 , 将两部分独立的排序 .  
1.  打乱数组 , 消除对输入的依赖 , 也可以切分时选择随机元素进行切分
2.  选取切分元素 , 将数组分为 左侧数组(小于等于切分元素) , 切分元素 , 右侧数组(大于等于切分元素) 三部分
    1.  选取左侧元素为切分元素
    2.  从数组左侧向右扫描 , 寻找第一个大于等于切分元素的元素
    3.  从数组右侧向左扫面 , 寻找第一个小于等于切分元素的元素
    4.  交换 2 和 3 中两个元素的位置
    5.  循环直到 左侧游标大于等于右侧游标 , 或者游标到达数组边界
3.  再递归的分别对左右两侧子数组进行切分 , 直到左右子数组有序 , 则数组完全有序

#### 2.3.2 性能特点
优势 : 
1.  简洁性, 内循环短小
2.  比较次数很少
3.  原地排序(只需很小的辅助栈)
4.  所需时间和 N * lgN 成正比

快速排序最好的情况是切分元素能讲数组对半切分

运行时间 : 
1. 比较次数 : 
    1.  对半切分时 : C(N) = 2C(N/2) + N = 2 * N * lnN , 约等于 1.39 * N * lgN 
    2.  最坏的切分情况 , 每次只切分一个元素 : C(N) = N + (N-1) + .. 2 + 1 = (N+1)*N/2
2. 交换次数 : 交换次数不会比比较次数更多  

相比归并排序 :  
1.  运行时间在 1.39 N * lgN, 但是大部分时候比归并排序快 , 虽然比较次数更多 , 但是移动次数更少

缺点 : 
1.  比较脆弱 , 依赖切分元素 ,  切分不平衡可能极为低效 , 实现时需要非常小新才能避免低劣的性能

#### 2.3.3 算法改进
###### 1) 切换到插入排序
1.  对小数组, 快速排序比插入排序慢
2.  因为递归, 快速排序的sort()方法在小数组也会调用自己
3.  if(hi <= lo)return; --> if (hi <= lo + M){Insertion.sort(a,lo,hi); return;} 
4.  转换参数M的最佳值和系统相关 , 5-15之间的值在大部分情况下令人满意

###### 2) 三区样切分
使用子数组中的一部分的中位数来切分 , 能切分的更好 , 代价是需要计算中位数 . 取样可设为3 

###### 3) 熵最优的排序
实际应用中经常会出现含有大量重复元素的数组 , 快速排序的递归性, 会使元素全部重复的子数组经常出现.
这就有很大改进潜力, 将当前实现的线性对数级的性能提高到线性级别 .
一个简单的想法是将数组切分为3部分 , 分别对应小于, 等于 , 大于切分元素的数组 . 
算法流程 : 
1.  从左到右遍历数组一次 , 维护一个指针 lt 使得 lo - lt-1 中的元素都小于v
2.  一个指针 gt 使得 gt+1 - hi 中的元素都大于v
3.  一个指针 i 使得 lt - i-1 中的元素都等于v
4.  i - gt 中的元素还未确定
5.  一开始 i 和 lo 相等 , 对a[i]进行比较
    1.  a[i] > v , a[lt] 和 a[i] 交换 , 将 lt 和 i 加一
    2.  a[i] < v , a[gt] 和 a[i] 交换 , gt 减一
    3.  a[i] = v , i加一
6.  这些操作都会保证数组元素不变 , 且缩小gt-i的值 
7.  除非和切分元素相等 , 其它元素都会被交换

运行时间 : 
1.  对于只有若干不同主键的随机数组 , 三向切分快速排序是线性的 . 主键值数量的N倍是运行时间的一个保守的上界
2.  所有主键均不重复时 , 比较次数为 2ln2 * N * lgN 
3.  那么对于任意输入 , 最优的基于比较的算法平均所需比较次数和三向切分的快速排序平均所需时间
的比较次数相互处于常数因子范围

特点 : 
对于包含大量重复元素的数组 , 它将排序时间从线性对数级别降低到了线性级别 

缺点 : 在重复元素不多时 , 比标准二分法多使用了很多次交换 .  
 

