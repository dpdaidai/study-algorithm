## 2.1初级排序算法
#### 2.1.1 游戏规则
###### 1) 验证
assert isSorted()
###### 2) 运行时间
评估算法的性能 : 
1.  计算各个算法在不同的随机输入下的基本操作的次数 : 比较 , 交换 , 读写数组
2.  用基本操作的次数来估计算法的相对性能
3.  验证猜想

###### 3) 额外的内存使用
排序算法的额外内存开销和运行时间是同等重要的    
排序算法可以分为 : 
1.  除了函数调用所需的栈和固定数目的实例变量之外无需额外内存 -- 原地排序算法
2.  需要额外内存空间来存储一份数组副本 -- 其它排序算法

###### 4) 数据类型
排序算法模版适用于任何实现了Comparable接口的数据类型

#### 2.1.2 选择排序
算法流程 : 
1.  首先找到数组中最小的元素
2.  其次, 将它和数组的第一个元素交换位置
3.  再次找到数组第二小的元素, 将它和数据的第二个元素交换位置

运行时间 : 
1. 比较次数 : N²/2
2. 交换次数 : N 

特点 : 
1.  运行时间和输入无关
2.  数据移动是最少的

#### 2.1.3 插入排序
算法流程 : 
1.  遍历数组 , 将当前元素插入到前面已经有序的元素中
2.  为了给要插入的元素腾出位置, 需要将其余元素在插入前都向右移

运行时间 : 
1.  输入为有序数组 , 或者所有元素相等 , 没有交换 , 比较次数为N-1
2.  输入为随机数组 : 比较次数 N²/4 , 交换次数 N²/4
3.  输入为逆序数组 : 比较次数 N²/2 , 交换次数 N²/2 

特点 : 
插入排序取决于元素的初始顺序, 对一个已经有序(或接近有序)的数组排序会快得多 . 

部分有序的数组: 
1.  数组中每个元素举例它的最终位置都不远
2.  一个有序大数组接一个小数组
3.  数组中只有几个元素位置不正确

#### 2.1.4 排序数组的可视化
#### 2.1.5 比较两种排序算法

#### 2.1.6 希尔排序
基于插入排序的优化算法 , 算法流程 :  
1.  改进了插入排序 , 是一个类似于插入排序 , 但使用了不同增量的过程
2.  交换不相邻的元素 , 以对数组的局部进行排序
3.  最终用插入排序将***局部有序***的数组排序
4.  它权衡了子数组的规模和有序性 . 排序之初 , 子数组很短 . 排序之后 , 子数组都是部分有序的. 

运行时间 : 运行时间达不到平方级别, 在本节的增量中 , 最坏的情况下 , 比较次数和N^3/2成正比

特点 : 
1.  适用于大型数组 , 对任意数组也有友好性
2.  希尔排序比插入和选择快得多 , 并且数组越大 , 优势越大
3.  代码量很小
4.  不需要额外内存空间
