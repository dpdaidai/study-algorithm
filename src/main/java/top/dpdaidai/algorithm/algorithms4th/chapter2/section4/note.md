## 2.4 优先队列
很多情况下 , 数据数量会变化 , 我们会收集一些元素 , 处理当前键值最大的元素 , 然后再收集更多的元素 , 
再处理当前键值最大的元素 . 
在这种情况下 , 一个合适的数据结构应该支持两种操作 : ***删除最大的元素和插入元素*** . 
这种数据结构叫做 ***优先队列***
本节内容 : 
1.  讨论优先队列的基本表现形式
2.  学习基于二叉堆数据结构的一种优先队列的经典实现方法
3.  用数组保存元素, 并按照一定条件排序, 以实现高效的(对数级别) ***删除最大元素和插入元素操作***

优先队列的用处举例 : 
1.  堆排序
2.  构造其它算法
3.  抽象若干重要的图搜索算法(第四章)
4.  开发一种数据压缩算法(第五章)

#### 2.4.1 API
MaxPQ
1.  构造方法
2.  插入元素
3.  返回最大元素
4.  删除并返回最大元素
5.  返回队列是否为空
6.  返回优先队列中的元素个数

MinPQ 仅需要改变less()比较的顺序

#### 2.4.2 初级实现
###### 1) 数组实现(无序)
###### 2) 数组实现(有序)
###### 3) 链表表示法

#### 2.4.3 堆的定义
当一颗二叉树的每个节点都大于等于它得两个子节点时 , 它被称为堆有序 . 
###### 1) 二叉堆表示法
使用二叉堆实现优先队列 , 我们将用数组表示一个二叉堆 , 利用它我们可以实现 ***对数级别*** 的 ***插入元素*** 和 
***删除最大元素*** 的操作
1.  数组 0 元素不使用
2.  节点k 的父节点为 k/2
3.  节点k 的子节点为 2k 和 2k+1
4.  通过计算数组的索引再书中上下移动

###### 2) 堆的算法
堆的操作 (插入元素和删除元素) 会打破堆的状态 , 然后需要按照要求将堆的状态恢复, 这个过程叫做 ***堆的有序化***
1.  由下至上的堆有序化(上浮swim)  
    如果某个节点变得比它的父节点更大而被打破 , 那么我们就需要通过交换他和它的父节点来修复
2.  由上至下的堆有序化(下沉sink)   
    如果某个节点变得比它的两个子节点其中之一更小, 那么通过交换它和它较大的子节点来恢复

操作 : 
1.  插入元素
    1.  将新元素加到数组末尾
    2.  增加堆的大小
    3.  让这个新元素上浮到合适的位置
2.  删除最大元素
    1.  将数组顶端的元素和数组最后的元素交换
    2.  取出最后的元素
    3.  将最后一个元素设置为null, 并减小堆的大小
    4.  将交换到顶端的元素下沉到合适位置

###### 3) 多叉堆
###### 4) 动态调整数组大小
###### 5) 元素主键不可表
###### 6) 索引优先队列
在很多应用中, 允许用例引用已经进入优先队列中的元素 . 做到这一点的一种简单方法是给每个元素一个索引
这种数据结构可以理解为一个能够快速访问其中最小元素的数组 . 

操作 : 
1.  插入一个元素 , 并和索引k关联
2.  将索引k的元素设置为item
3.  检查是否存在索引为k的元素
4.  删除索引k以及其关联的元素
5.  返回最小元素
6.  返回最小元素的索引
7.  删除最小元素并返回它的索引

实现:
1.  pq[] 保存索引
2.  keys[] 保存元素
3.  qp[] 保存 pq[] 的逆序 , qp[pq[i]] = pq[qp[i]] = i
4.  若 索引 i 不在队列中 , 则总是另 qp[i] = -1

###### 7) 索引优先队列用例

#### 2.4.5 堆排序
我们可以将任意优先队列标称一种排序方法 , 反复调用优先队列中的删除最小元素的操作来将它们按顺序取出并得到排序结果

算法流程 : 
1.  将元素数组构造成一个有序的二叉堆
2.  在下沉阶段 , 我们从堆中按顺序取出所有元素 , 并得到排序结果

###### 1) 堆的构造
1.  从左到右遍历数组, 用swim()保证扫面完所有元素后 , 数组已经是一颗有序的堆
2.  从右向左 , 由 N/2 起遍历数组 , 用sink()方法将每个节点下沉 , 仅需遍历一半的元素, 即使得堆有序  

运行时间 : 
1.  比较次数 : 2N
2.  交换次数 : N 

###### 2) 下沉排序
1.  将首部的元素和数组尾部交换
2.  堆大小-1
3.  将首部元素下沉 , 恢复堆有序
4.  循环直到堆为空

运行时间 : 
1.  比较次数 : 2 * N * lgN
2.  交换次数 : N * lgN 

特点 : 
1.  唯一能同时最优的利用空间和时间的方法 
2.  在最坏时也能保证使用 2NlgN次比较和恒定的空间
3.  空间紧张的时候 , 它的代码量很小也能获得较好性能
4.  适合动态场景, 对插入和修改最大元素操作友好 , 且能保证对数级别的运行时间

缺点 : 
现代系统中的应用很少使用它 , 因为它数组元素很少和相邻的其它元素比较 , 因此缓存命中率远远低于其它
比较都在相邻元素的算法 , 如 快速排序 , 归并排序 , 希尔排序 
