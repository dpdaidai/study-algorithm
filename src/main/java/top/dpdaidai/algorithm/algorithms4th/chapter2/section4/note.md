## 2.4 优先队列
很多情况下 , 数据数量会变化 , 我们会收集一些元素 , 处理当前键值最大的元素 , 然后再收集更多的元素 , 
再处理当前键值最大的元素 . 
在这种情况下 , 一个合适的数据结构应该支持两种操作 : ***删除最大的元素和插入元素*** . 
这种数据结构叫做 ***优先队列***
本节内容 : 
1.  讨论优先队列的基本表现形式
2.  学习基于二叉堆数据结构的一种优先队列的经典实现方法
3.  用数组保存元素, 并按照一定条件排序, 以实现高效的(对数级别) ***删除最大元素和插入元素操作***

优先队列的用处举例 : 
1.  堆排序
2.  构造其它算法
3.  抽象若干重要的图搜索算法(第四章)
4.  开发一种数据压缩算法(第五章)

#### 2.4.1 API
MaxPQ
1.  构造方法
2.  插入元素
3.  返回最大元素
4.  删除并返回最大元素
5.  返回队列是否为空
6.  返回优先队列中的元素个数

MinPQ 仅需要改变less()比较的顺序

#### 2.4.2 初级实现
###### 1) 数组实现(无序)
###### 2) 数组实现(有序)
###### 3) 链表表示法

#### 2.4.3 堆的定义
当一颗二叉树的每个节点都大于等于它得两个子节点时 , 它被称为堆有序 . 
###### 1) 二叉堆表示法
使用二叉堆实现优先队列 , 我们将用数组表示一个二叉堆 , 利用它我们可以实现 ***对数级别*** 的 ***插入元素*** 和 
***删除最大元素*** 的操作
1.  数组 0 元素不使用
2.  节点k 的父节点为 k/2
3.  节点k 的子节点为 2k 和 2k+1
4.  通过计算数组的索引再书中上下移动

###### 2) 堆的算法
堆的操作 (插入元素和删除元素) 会打破堆的状态 , 然后需要按照要求将堆的状态恢复, 这个过程叫做 ***堆的有序化***
1.  由下至上的堆有序化(上浮swim)  
    如果某个节点变得比它的父节点更大而被打破 , 那么我们就需要通过交换他和它的父节点来修复
2.  由上至下的堆有序化(下沉sink)   
    如果某个节点变得比它的两个子节点其中之一更小, 那么通过交换它和它较大的子节点来恢复

操作 : 
1.  插入元素
    1.  将新元素加到数组末尾
    2.  增加堆的大小
    3.  让这个新元素上浮到合适的位置
2.  删除最大元素
    1.  将数组顶端的元素和数组最后的元素交换
    2.  取出最后的元素
    3.  将最后一个元素设置为null, 并减小堆的大小
    4.  将交换到顶端的元素下沉到合适位置

###### 3) 多叉堆
###### 4) 动态调整数组大小
###### 5) 元素主键不可表
###### 6) 索引优先队列
