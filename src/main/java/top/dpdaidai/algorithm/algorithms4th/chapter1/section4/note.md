## 1.4 算法分析
```
1   我的程序运行了多长时间
2   为什么我的程序耗尽了几乎所有内存
```
我们将会使用*数学分析*为算法成本建立简洁的模型并使用实验数据验证这些模型 .   

#### 1.4.1 科学方法
1.  细致的观察, 并且测量
2.  根据观察提出假设模型
3.  根据模型预测未来的事件
4.  核实预测的准确性
5.  如此反复直到确认预测和观察一致

#### 1.4.2 观察
重点研究如何更好的将问题规模和运行时间的关系量化
###### 1) 举例
###### 2) 计时器
###### 3) 实验数据的分析
1. 程序在不同计算机上的运行时间只比通常时一个常数
2. 将问题规模和程序运行时间作为函数,  绘制成图表 , 进而得到关于运行时间的函数表达式 
3. 由2的函数表达式 , 预测更大数据时的运行时间 , 进而验证表达式的正确性   

#### 1.4.3 数学模型
一个程序运行总时间主要和两点有关
1.  执行每条语句的耗时
2.  执行每条语句的频率

###### 1) 近似
1.  函数 f(N) = N(N-1)(N-2)/6 
2.  近似函数 ~f(N) = N^3 / 6
3.  增长数量级 g(N) = N^3

###### 2) 近似运行时间
1.  要得到一个Java总运行时间的数学表达式, 原则上要找出每一条指令的运行次数和分别的运行时间
2.  我们根据执行频率将Java语句分块, 计算出每总频率的首项近似 , 判定每条指令的执行成本并计算总和
3.  某些执行频率依赖输入
4.  我们假设每个Java代码块的所对应的机器指令集所需的执行时间都是固定的, t0,t1,t2.. 
5.  从小红我们观察到一个关键现象时执行最频繁的指令决定了程序执行的总时间 --- 我们将这些指令称为程序的内循环
6.  这是很典型的情况 : 许多程序的运行时间只取决于其中的一小部分指令

###### 3) 对增长数量级的猜想
1.  本书使用***性质***表示需要用实验验证的猜想.(我认为就是假设的意思)
2.  证明 : 数学分析的最终结果和实验最终结果完全与假设吻合即证明
3.  常数a取决于计算机的具体配置, 我们无需在意特定系统的常数值

###### 4) 算法的分析
1.  类似与***性质***的猜想和重要 , 因为它们将抽象时间中的一个Java程序和真实世界中运行它的一台计算机联系了起来
2.  增长数量级概念的应用 : 将程序和它实现的算法隔离开来 , 算法决定增长数量级 , 无需在意程序运行在什么系统

###### 5) 成本模型
成本模型用来评估算法的***性质*** . 这个模型定义了我们所研究的算法的基本操作
1.  我们使用***命题***来表示在某个成本模型下的算法的数学性质
2.  在全书我们会使用某个确定的成本模型研究算法 
3.  **我们希望通过明确成本模型使给定实现所需运行时间的增长数量级和它本后算法成本的增长数量级相同**
4.  我们会研究算法准确的数学性质(命题)并对实现的性能做出猜想(性质), 可通过实验验证这些猜想
5.  ***命题***的数学结论支持了***性质***中由科学方法得到并由实验验证过的猜想

###### 6) 总结
对于大多数程序 , 得到其运行时间的数学模型所需步骤如下 :
1.  确定输入模型, 定义问题的规模
2.  识别内循环
3.  根据内循环中的操作确定成本模型
4.  对于给定的输入, 判断这些操作的执行频率

#### 1.4.4 增长数量级的分类
我们实现算法时使用了几种结构性的原语 , 所以成本增长的数量级一般都是问题规模N的若干函数之一
###### 1) 常数级别
普通语句
###### 2) 对数级别
二分策略
###### 3) 线性级别
循环
###### 4) 线性对数级别
分治 , 归并排序
###### 5) 平方级别
双层循环
###### 6) 立方级别
三层循环
###### 7) 指数方级别
穷举查找 , 检查所有子集

###### 8) 描述
我们可以在某个成本模型下提出十分准确的命题.
例如 : 归并排序所需的比较次数在 1/2 * N * lgN 到 N * lgN 之间 , 由此我们可知归并排序所需的运行之间的增长数量级时线性对数的.
简写为 : 归并排序时线性对数的 

#### 1.4.5 设计更快的算法
###### 1) 2-sum
###### 2) 3-sum的快速算法
###### 3) 下界
###### 4) 总结
1.  实现并分析问题的一种简单解法
2.  考察算法的各种改进
3.  用实验证明新的算法更快
