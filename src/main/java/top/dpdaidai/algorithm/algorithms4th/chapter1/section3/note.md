## 1.3 背包 队列 栈
本节中的实现和用例代码展示了我们开发数据结构和算法的一般方法
+   第一个目标时说明我们对集合中的对象的表示方式将直接影响各种操作的效率.
+   第二个目标是介绍 *泛型* 和 *迭代*
+   第三个目标时介绍并说明链式数据结构的重要性 , 特别时经典数据结构链表 , 有了它才能高效的实现背包
队列和栈        

理解链表时学习各种算法和数据结构中最关键的第一步 . 

#### 1.3.1 API 
+   设计API
+   设计用例
+   讨论数据类型的值的所有可能的表示方法以及各种操作的实现

###### 1) 泛型
泛型也叫做参数化类型
+   它是一个象征性的占位符 , 表示的是用例将会使用的某种具体数据类型 . 
+   在创建栈时 , 用例会提供一种具体的数据类型来替换泛型 . 
+   如果没有泛型 , 我们必须为需要收集的没中数据类型定义并实现不同的API .

###### 2) 自动装箱
+   自动将原始数据类型转换为一个封装类型称为自动装箱
+   自动将一个封箱类型转换为一个原始数据类型被称为自动拆箱

###### 3) 可迭代的集合类型
对于许多应用场景 , 用例的要求只是用某种方式处理集合中的每个元素, 或者叫做迭代访问集合中的元素. 

###### 4) 背包
背包是一种集合数据类型
+   不支持从中删除元素
+   用来收集元素并迭代遍历所有的收集到的元素
+   迭代的顺序不确定且和用例无关

###### 5) 先进先出队列
队列是一种基于先进先出(FIFO)策略的集合类型 , 队列是许多日常现象的自然模型

###### 6) 下压栈
基于后进先出(LIFO)策略的集合类型 . 使用foreach遍历时, 元素的处理顺序和压入的顺序相反 . 

###### 7) 算术表达式求值

#### 1.3.2 集合类数据类型的实现
在讨论Bag, Queue , Stack 前 , 先给出一个简单而经典的实现. 再讨论它的改进

###### 1) 定容栈
它是表示固定容量的字符串栈的抽象数据类型
+ 只能处理String值
+ 要求用例指定容量
+ 不支持迭代

###### 2) 泛型
利用泛型将 定容栈 改进为 泛型定容栈

###### 3) 动态调整数组大小
当容量满时 , 将数组长度翻倍
当容量小于等于1/4时 , 将数组长度缩短一半

###### 4) 对象游离
在将数据pop之后 , 数组任然持有对象的引用 , 虽然从栈的角度来说 , 我们永远也不会在使用到它 . 
此时需要将该元素的引用设置为null , 让垃圾回收器可以回收它 . 

###### 5) 迭代
实现Iterable中的接口使得任意集合数据类型可以迭代
1.  集合数据类型必须实现一个iterator()方法并返回一个Iterator对象
2.  Iterator类必须包含两个方法 : hasNext()和next()
3.  在数据类型中实现一个Iterator嵌套类 , 它可以访问包含它的类的实例变量

``` 
经过上述5点对定容栈的修改 , 我们已经得到一个几乎达到任意集合类数据类型的实现
1.  每项操作用时都和集合大小无关
2.  空间需求总是不超过集合大小乘以常数
缺点 : push()和pop()操作会调整数组的大小, 这项耗时和栈大小成正比 . 下一节将克服这个缺陷
```

#### 1.3.3 链表
这是我们构造非Java直接支持的数据结构的第一个例子 . 在链表中向序列插入元素或是删除元素都更方便
###### 1) 节点记录Node
###### 2) 构造链表
###### 3) 在表头插入节点
###### 4) 从表头删除节点
###### 5) 在表尾删除节点
###### 6) 其它位置的插入和删除操作
###### 7) 栈的实现
###### 8) 队列的实现
###### 9) 背包的实现

#### 1.3.4 综述
我们在本节中描述数据结构和算法的方式是全书的原型 . 
在研究一个新的应用领域时, 我们将会按照以下步骤识别目标并使用数据抽象解决问题 . 
1.  定义API
2.  根据特定的应用场景开发用例代码
3.  在抽象类型的实现中定义实例变量
4.  实现类中的实例方法 , 即算法
5.  分析算法的性能特点.
